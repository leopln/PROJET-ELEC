#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <EEPROM.h>
#include <string.h>
#include <stdio.h>

// ===================== OLED =====================
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ===================== PINS =====================
const int PIN_ENC_A   = 3;   // Encodeur A
const int PIN_ENC_B   = 4;   // Encodeur B
const int PIN_ENC_SW  = 2;   // Bouton encodeur (SW2)
const int PIN_SW3     = A6;  // Bouton SW3 (analogique)

const int PIN_LED_R   = 5;
const int PIN_LED_G   = 6;
const int PIN_LED_B   = 9;
const int PIN_BUZZER  = 10;

const int PIN_CE      = 7;
const int PIN_CSN     = 8;

// ===================== RADIO =====================
RF24 radio(PIN_CE, PIN_CSN);
const byte RF_ADDRESS[6] = "00001";

// ===================== REGLAGES (FS5) =====================
struct Settings {
  uint8_t marker;      // 0x51 si initialisé
  uint8_t channel;     // 1..100
  uint8_t pseudoIndex; // 0..NB_PSEUDOS-1
  uint8_t sound;       // 1..3
};

Settings settings;

const char* PSEUDOS[] = {
  "Bip1",
  "Bip2",
  "Bip3",
  "Bip4",
  "Bip5"
};
const uint8_t NB_PSEUDOS = sizeof(PSEUDOS) / sizeof(PSEUDOS[0]);

// ===================== CLAVIER (FS1) =====================
const char KEYBOARD[] =
  "AZERTYUIOP"
  "QSDFGHJKLM"
  "WXCVBN,.;!?";  // 30 caractères

const int KB_LEN      = sizeof(KEYBOARD) - 1; // 30 touches
const int INDEX_SPACE = KB_LEN;              // 30
const int INDEX_DEL   = KB_LEN + 1;          // 31
const int INDEX_SEND  = KB_LEN + 2;          // 32
const int TOTAL_KEYS  = KB_LEN + 3;          // 33

#define MAX_MESSAGE_LEN 100
char   messageBuf[MAX_MESSAGE_LEN + 1];
int    messageLen       = 0;
uint8_t messagePriority = 0; // 0 / 1 / 2
int    cursorIndex      = 0;

// ===================== ENCODEUR =====================
int lastEncA         = HIGH;
int lastEncSW        = HIGH;
unsigned long lastStepTime   = 0;
unsigned long lastButtonTime = 0;

bool sw3WasDown      = false;
unsigned long sw3DownTime = 0;
bool inSettings      = false;
bool oledOK          = true;

// ===================== PROTOTYPES =====================
void encoderInit();
int  readEncoderStep();
bool readEncoderPush();

void loadSettings();
void saveSettings();
void enterSettings();
void editChannel();
void editPseudo();
void editSound();

void radioInit();
void sendMessage();

void addChar(char c);
void deleteChar();
void drawComposeUI();
void playSendBeep();

// =====================================================
//                    ENCODEUR
// =====================================================

void encoderInit() {
  pinMode(PIN_ENC_A,  INPUT_PULLUP);
  pinMode(PIN_ENC_B,  INPUT_PULLUP);
  pinMode(PIN_ENC_SW, INPUT_PULLUP);
  lastEncA  = digitalRead(PIN_ENC_A);
  lastEncSW = digitalRead(PIN_ENC_SW);
}

int readEncoderStep() {
  const unsigned long debounceMs = 3;
  unsigned long now = millis();
  if (now - lastStepTime < debounceMs) return 0;

  int step = 0;
  int a = digitalRead(PIN_ENC_A);
  if (a != lastEncA) {
    if (a == LOW) {          // front descendant
      int b = digitalRead(PIN_ENC_B);
      if (b == HIGH) step = +1;
      else           step = -1;
      lastStepTime = now;
    }
  }
  lastEncA = a;
  return step;
}

bool readEncoderPush() {
  bool pressed = false;
  int state = digitalRead(PIN_ENC_SW);
  unsigned long now = millis();
  const unsigned long debounceMs = 150;

  if (state != lastEncSW) {
    if (now - lastButtonTime > debounceMs) {
      if (state == LOW && lastEncSW == HIGH) {
        pressed = true;
      }
      lastButtonTime = now;
    }
  }
  lastEncSW = state;
  return pressed;
}

// =====================================================
//                 REGLAGES (FS5)
// =====================================================

void loadSettings() {
  EEPROM.get(0, settings);
  if (settings.marker != 0x51) {
    settings.marker      = 0x51;
    settings.channel     = 76;
    settings.pseudoIndex = 0;
    settings.sound       = 1;
    EEPROM.put(0, settings);
  }
}

void saveSettings() {
  settings.marker = 0x51;
  EEPROM.put(0, settings);
}

void playSendBeep() {
  int freq = 1200;
  if (settings.sound == 2) freq = 1800;
  if (settings.sound == 3) freq = 800;
  tone(PIN_BUZZER, freq, 120);
}

void editChannel() {
  bool done = false;
  while (!done) {
    if (oledOK) {
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(0, 0);
      display.println(F("Canal radio (1..100)"));
      display.setTextSize(2);
      display.setCursor(40, 30);
      display.print(settings.channel);
      display.display();
    }

    int step = readEncoderStep();
    if (step != 0) {
      int ch = (int)settings.channel + step;
      if (ch < 1)   ch = 1;
      if (ch > 100) ch = 100;
      settings.channel = (uint8_t)ch;
    }

    if (readEncoderPush()) {
      done = true;
      delay(200);
    }
  }
}

void editPseudo() {
  bool done = false;
  while (!done) {
    if (oledOK) {
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(0, 0);
      display.println(F("Choix pseudo"));
      display.setTextSize(2);
      display.setCursor(10, 30);
      display.print(PSEUDOS[settings.pseudoIndex]);
      display.display();
    }

    int step = readEncoderStep();
    if (step != 0) {
      int idx = (int)settings.pseudoIndex + step;
      if (idx < 0) idx = 0;
      if (idx >= (int)NB_PSEUDOS) idx = NB_PSEUDOS - 1;
      settings.pseudoIndex = (uint8_t)idx;
    }

    if (readEncoderPush()) {
      done = true;
      delay(200);
    }
  }
}

void editSound() {
  bool done = false;
  while (!done) {
    if (oledOK) {
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(0, 0);
      display.println(F("Type sonnerie (1..3)"));
      display.setTextSize(2);
      display.setCursor(60, 30);
      display.print(settings.sound);
      display.display();
    }

    int step = readEncoderStep();
    if (step != 0) {
      int s = (int)settings.sound + step;
      if (s < 1) s = 1;
      if (s > 3) s = 3;
      settings.sound = (uint8_t)s;
      playSendBeep();
    }

    if (readEncoderPush()) {
      done = true;
      delay(200);
    }
  }
}

// Menu réglages appelé par appui long sur SW3
void enterSettings() {
  inSettings = true;
  int menu = 0; // 0: canal, 1: pseudo, 2: son, 3: quitter
  bool running = true;

  while (running) {
    if (oledOK) {
      display.clearDisplay();
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(0, 0);
      display.println(F("REGLAGES EMETTEUR"));

      display.setCursor(0, 16);
      if (menu == 0) display.print(F("> "));
      else           display.print(F("  "));
      display.print(F("Canal: "));
      display.println(settings.channel);

      display.setCursor(0, 28);
      if (menu == 1) display.print(F("> "));
      else           display.print(F("  "));
      display.print(F("Pseudo: "));
      display.println(PSEUDOS[settings.pseudoIndex]);

      display.setCursor(0, 40);
      if (menu == 2) display.print(F("> "));
      else           display.print(F("  "));
      display.print(F("Son: "));
      display.println(settings.sound);

      display.setCursor(0, 52);
      if (menu == 3) display.print(F("> "));
      else           display.print(F("  "));
      display.println(F("Quitter"));
      display.display();
    }

    int step = readEncoderStep();
    if (step != 0) {
      menu += step;
      if (menu < 0) menu = 3;
      if (menu > 3) menu = 0;
    }

    if (readEncoderPush()) {
      delay(150);
      if (menu == 0)      editChannel();
      else if (menu == 1) editPseudo();
      else if (menu == 2) editSound();
      else if (menu == 3) running = false;
    }
  }

  saveSettings();
  radioInit();  // appliquer nouveau canal
  inSettings = false;
}

// =====================================================
//                      RADIO (FS2)
// =====================================================

void radioInit() {
  if (!radio.begin()) {
    // Si la radio est HS on bloque (sinon comportement bizarre)
    while (1) {}
  }

  radio.setPALevel(RF24_PA_LOW);
  radio.setDataRate(RF24_250KBPS);

  uint8_t ch = 0;
  if (settings.channel >= 1 && settings.channel <= 100) {
    ch = settings.channel - 1;
  }
  radio.setChannel(ch);

  radio.openWritingPipe(RF_ADDRESS);
  radio.stopListening();
}

void sendMessage() {
  if (messageLen == 0) return;

  const char* pseudo = "Anon";
  if (settings.pseudoIndex < NB_PSEUDOS) {
    pseudo = PSEUDOS[settings.pseudoIndex];
  }

  // 1) HEADER : FROM:<pseudo>|P<prio>
  char headerPayload[32];
  memset(headerPayload, 0, sizeof(headerPayload));

  char header[32];
  snprintf(header, sizeof(header), "FROM:%s|P%d", pseudo, (int)messagePriority);
  strncpy(headerPayload, header, sizeof(headerPayload) - 1);

  radio.write(&headerPayload, sizeof(headerPayload));
  delay(20);

  // 2) Corps du message en tronçons (31 caractères max)
  const int CHUNK_SIZE = 31;
  int pos = 0;
  while (pos < messageLen) {
    char chunkBuffer[CHUNK_SIZE + 1];
    memset(chunkBuffer, 0, sizeof(chunkBuffer));

    int toCopy = messageLen - pos;
    if (toCopy > CHUNK_SIZE) toCopy = CHUNK_SIZE;
    memcpy(chunkBuffer, &messageBuf[pos], toCopy);

    radio.write(&chunkBuffer, sizeof(chunkBuffer));
    pos += toCopy;
    delay(20);
  }

  // 3) Marqueur de fin
  char endMarker[32];
  memset(endMarker, 0, sizeof(endMarker));
  strcpy(endMarker, "END");
  radio.write(&endMarker, sizeof(endMarker));

  // Confirmation FS3 "soft"
  if (oledOK) {
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.println(F("Message envoye !"));
    display.display();
  }
  playSendBeep();
  delay(500);

  // Reset message
  messageLen    = 0;
  messageBuf[0] = '\0';
  if (oledOK) drawComposeUI();
}

// =====================================================
//                  CLAVIER / FS1
// =====================================================

void addChar(char c) {
  if (messageLen < MAX_MESSAGE_LEN) {
    messageBuf[messageLen++] = c;
    messageBuf[messageLen]   = '\0';
  }
}

void deleteChar() {
  if (messageLen > 0) {
    messageLen--;
    messageBuf[messageLen] = '\0';
  }
}

void drawComposeUI() {
  if (!oledOK) return;

  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);

  // Barre de saisie
  display.drawRect(0, 0, 128, 16, SSD1306_WHITE);

  int maxChars = 18;
  int start = 0;
  if (messageLen > maxChars) start = messageLen - maxChars;

  display.setCursor(3, 4);
  for (int i = start; i < messageLen; i++) {
    display.print(messageBuf[i]);
  }

  // Priorité
  display.setCursor(96, 4);
  display.print(F("P="));
  display.print(messagePriority);

  // Ligne 1
  for (int i = 0; i < 10; i++) {
    int x = i * 12;
    if (cursorIndex == i) {
      display.fillRect(x, 18, 12, 10, SSD1306_WHITE);
      display.setTextColor(SSD1306_BLACK);
    } else {
      display.setTextColor(SSD1306_WHITE);
    }
    display.setCursor(x + 3, 20);
    display.print(KEYBOARD[i]);
  }

  // Ligne 2
  for (int i = 10; i < 20; i++) {
    int x = (i - 10) * 12;
    if (cursorIndex == i) {
      display.fillRect(x, 30, 12, 10, SSD1306_WHITE);
      display.setTextColor(SSD1306_BLACK);
    } else {
      display.setTextColor(SSD1306_WHITE);
    }
    display.setCursor(x + 3, 32);
    display.print(KEYBOARD[i]);
  }

  // Ligne 3
  for (int i = 20; i < KB_LEN; i++) {
    int x = (i - 20) * 12;
    if (cursorIndex == i) {
      display.fillRect(x, 42, 12, 10, SSD1306_WHITE);
      display.setTextColor(SSD1306_BLACK);
    } else {
      display.setTextColor(SSD1306_WHITE);
    }
    display.setCursor(x + 3, 44);
    display.print(KEYBOARD[i]);
  }

  display.setTextColor(SSD1306_WHITE);
  int y = 52;
  int h = 10;

  // SPACE
  if (cursorIndex == INDEX_SPACE) {
    display.fillRect(0, y, 40, h, SSD1306_WHITE);
    display.setCursor(2, y + 2);
    display.setTextColor(SSD1306_BLACK);
  } else {
    display.drawRect(0, y, 40, h, SSD1306_WHITE);
    display.setCursor(2, y + 2);
    display.setTextColor(SSD1306_WHITE);
  }
  display.print(F("SPACE"));

  // DEL
  if (cursorIndex == INDEX_DEL) {
    display.fillRect(45, y, 30, h, SSD1306_WHITE);
    display.setCursor(48, y + 2);
    display.setTextColor(SSD1306_BLACK);
  } else {
    display.drawRect(45, y, 30, h, SSD1306_WHITE);
    display.setCursor(48, y + 2);
    display.setTextColor(SSD1306_WHITE);
  }
  display.print(F("DEL"));

  // SEND
  if (cursorIndex == INDEX_SEND) {
    display.fillRect(80, y, 40, h, SSD1306_WHITE);
    display.setCursor(84, y + 2);
    display.setTextColor(SSD1306_BLACK);
  } else {
    display.drawRect(80, y, 40, h, SSD1306_WHITE);
    display.setCursor(84, y + 2);
    display.setTextColor(SSD1306_WHITE);
  }
  display.print(F("SEND"));

  display.display();
}

// =====================================================
//                    SETUP / LOOP
// =====================================================

void setup() {
  pinMode(PIN_BUZZER, OUTPUT);
  digitalWrite(PIN_BUZZER, LOW);

  pinMode(PIN_LED_R, OUTPUT);
  pinMode(PIN_LED_G, OUTPUT);
  pinMode(PIN_LED_B, OUTPUT);
  analogWrite(PIN_LED_R, 0);
  analogWrite(PIN_LED_G, 0);
  analogWrite(PIN_LED_B, 0);

  encoderInit();

  Wire.begin();
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    oledOK = false;
  }

  if (oledOK) {
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.println(F("BIPBIP Emission"));
    display.display();
    delay(700);
  }

  loadSettings();
  radioInit();

  messageLen      = 0;
  messageBuf[0]   = '\0';
  messagePriority = 0;
  cursorIndex     = 0;

  if (oledOK) drawComposeUI();
}

void loop() {
  if (!inSettings) {
    // 1) Clavier (rotation)
    int step = readEncoderStep();
    if (step != 0) {
      cursorIndex += step;
      if (cursorIndex < 0)           cursorIndex = TOTAL_KEYS - 1;
      if (cursorIndex >= TOTAL_KEYS) cursorIndex = 0;
      drawComposeUI();
    }

    // 2) Clic sur l'encodeur
    if (readEncoderPush()) {
      if (cursorIndex == INDEX_SPACE) {
        addChar(' ');
      } else if (cursorIndex == INDEX_DEL) {
        deleteChar();
      } else if (cursorIndex == INDEX_SEND) {
        sendMessage();
      } else {
        addChar(KEYBOARD[cursorIndex]);
      }
      drawComposeUI();
    }

    // 3) Gestion SW3 (priorite courte, reglages longue)
    int val = analogRead(PIN_SW3);
    bool sw3Now = (val < 300);

    if (sw3Now && !sw3WasDown) {
      sw3DownTime = millis();
    }

    if (!sw3Now && sw3WasDown) {
      unsigned long duration = millis() - sw3DownTime;
      if (duration < 700) {
        // Appui court : changer la priorité
        messagePriority = (messagePriority + 1) % 3;
        drawComposeUI();
      }
    }

    if (sw3Now && !inSettings && (millis() - sw3DownTime > 1000)) {
      // Appui long : réglages
      enterSettings();
      // Attendre le relâchement de SW3
      while (analogRead(PIN_SW3) < 300) {
        delay(10);
      }
      sw3WasDown   = false;
      sw3DownTime  = 0;
      if (oledOK) drawComposeUI();
    }

    sw3WasDown = sw3Now;
  }
}
